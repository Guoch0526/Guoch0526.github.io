<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>理解javascript中的this | Guoch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#495ed3">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="在学习javascript的过程中，有时候对于this的指向感觉迷迷糊糊的，所以我在查阅了相关资料之后针对javascript中的this做一个总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="理解javascript中的this">
<meta property="og:url" content="http://www.vituyun.com/2016/09/20/理解javascript中的this/index.html">
<meta property="og:site_name" content="Guoch">
<meta property="og:description" content="在学习javascript的过程中，有时候对于this的指向感觉迷迷糊糊的，所以我在查阅了相关资料之后针对javascript中的this做一个总结。">
<meta property="og:updated_time" content="2017-10-08T00:39:39.265Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解javascript中的this">
<meta name="twitter:description" content="在学习javascript的过程中，有时候对于this的指向感觉迷迷糊糊的，所以我在查阅了相关资料之后针对javascript中的this做一个总结。">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="https://rawcdn.githack.com/Guoch0526/Guoch0526.github.io/master/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Guoch</h5>
          <a href="mailto:Gch_hong@163.com" title="Gch_hong@163.com" class="mail">Gch_hong@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/css"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Guoch0526" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">理解javascript中的this</div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">理解javascript中的this</h1>
        <h5 class="subtitle">
            
                <time datetime="2016-09-20T06:26:57.000Z" itemprop="datePublished" class="page-time">
  2016-09-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/javaScript/">javaScript</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#全局执行"><span class="post-toc-number">1.</span> <span class="post-toc-text">全局执行</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#总结：在全局作用域中它的-this-执行当前的全局对象（浏览器端是-Window，node-中是-global）。"><span class="post-toc-number">1.0.0.0.1.</span> <span class="post-toc-text">　　总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数中执行"><span class="post-toc-number">2.</span> <span class="post-toc-text">函数中执行</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#纯粹的函数调用"><span class="post-toc-number">2.0.0.1.</span> <span class="post-toc-text">纯粹的函数调用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#严格模式-‘use-strict’"><span class="post-toc-number">2.0.0.2.</span> <span class="post-toc-text">严格模式 ‘use strict’;</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#作为对象的方法调用"><span class="post-toc-number">3.</span> <span class="post-toc-text">作为对象的方法调用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一些问题"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">一些问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解决"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">解决</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#setTimeout-的另一个问题"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">setTimeout 的另一个问题</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#作为一个构造函数使用"><span class="post-toc-number">4.</span> <span class="post-toc-text">作为一个构造函数使用</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#箭头函数"><span class="post-toc-number">5.</span> <span class="post-toc-text">箭头函数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#call-apply-bind"><span class="post-toc-number">6.</span> <span class="post-toc-text">call, apply, bind</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#在-js-中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的-this-指向："><span class="post-toc-number">6.0.0.0.1.</span> <span class="post-toc-text">　　在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#·call"><span class="post-toc-number">6.0.0.1.</span> <span class="post-toc-text">　　·call</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#·apply"><span class="post-toc-number">6.0.0.2.</span> <span class="post-toc-text">　　·apply</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#·bind"><span class="post-toc-number">6.0.0.3.</span> <span class="post-toc-text">　　·bind</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为箭头函数指定-this"><span class="post-toc-number">6.0.1.</span> <span class="post-toc-text">为箭头函数指定 this</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-理解javascript中的this"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">理解javascript中的this</h1>
        <div class="post-meta">
            <time class="post-time" title="2016-09-20 14:26:57" datetime="2016-09-20T06:26:57.000Z"  itemprop="datePublished">2016-09-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/javaScript/">javaScript</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>　　在学习javascript的过程中，有时候对于this的指向感觉迷迷糊糊的，所以我在查阅了相关资料之后针对javascript中的this做一个总结。<br><a id="more"></a></p>
<h1 id="全局执行"><a href="#全局执行" class="headerlink" title="全局执行"></a>全局执行</h1><hr>
<p>　　首先，我们在全局环境中看看它的this是什么：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//浏览器环境，可以看到打印出了 window 对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//node环境，可以看到打印出了 global 对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// global</span></div></pre></td></tr></table></figure>
<h5 id="总结：在全局作用域中它的-this-执行当前的全局对象（浏览器端是-Window，node-中是-global）。"><a href="#总结：在全局作用域中它的-this-执行当前的全局对象（浏览器端是-Window，node-中是-global）。" class="headerlink" title="　　总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。"></a>　　总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。</h5><h1 id="函数中执行"><a href="#函数中执行" class="headerlink" title="函数中执行"></a>函数中执行</h1><hr>
<h4 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">test();</div><div class="line"></div><div class="line"><span class="comment">// Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125;</span></div></pre></td></tr></table></figure>
<p>　　我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象；</p>
<h4 id="严格模式-‘use-strict’"><a href="#严格模式-‘use-strict’" class="headerlink" title="严格模式 ‘use strict’;"></a>严格模式 ‘use strict’;</h4><p>　　如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">test(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>　　当然，把它放在一个立即执行函数中会更好，避免了污染全局：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">  "use strict"</span>;</div><div class="line">　<span class="built_in">console</span>.log(<span class="keyword">this</span>);     <span class="comment">// undefined</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h1 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h1><hr>
<p>　　当一个函数被当作一个对象的方法调用的时候：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span>,</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo();      <span class="comment">// 'Guoch'</span></div></pre></td></tr></table></figure></p>
<p>　　这时候，this 指向当前的这个对象；当然，我们还可以这么做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span>,</div><div class="line">  foo: test</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo();      <span class="comment">// 'Guoch'</span></div></pre></td></tr></table></figure></p>
<p>　　同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。</p>
<p>　　如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span>,</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = obj.foo;</div><div class="line">test();     <span class="comment">// Window</span></div></pre></td></tr></table></figure></p>
<p>　　可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><hr>
<p>　　我们经常在回调函数里面会遇到一些问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span>,</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    setTimeout(<span class="keyword">this</span>.foo, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo2();</div></pre></td></tr></table></figure></p>
<p>　　执行这段代码我们会发现两次打印出来的 this 是不一样的：</p>
<p>　　第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑；但是在 setTimeout 中执行的 this.foo ，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑；<br>　　其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。这个问题是很多异步回调函数中普遍会碰到的；</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><hr>
<p>　　为了解决这个问题，我们可以利用闭包的特性来处理：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span>,</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Window</span></div><div class="line"></div><div class="line">      <span class="built_in">console</span>.log(_this);  <span class="comment">// Object &#123;name: "Guoch"&#125;</span></div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo2();</div></pre></td></tr></table></figure></p>
<p>　　可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用 _this，就可以指向当前的这个对象了；</p>
<h3 id="setTimeout-的另一个问题"><a href="#setTimeout-的另一个问题" class="headerlink" title="setTimeout 的另一个问题"></a>setTimeout 的另一个问题</h3><hr>
<p>　　之前说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(foo, <span class="number">1</span>);     <span class="comment">// window</span></div></pre></td></tr></table></figure></p>
<p>　　按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()；</p>
<p>　　当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);</p>
<p>[<a href="http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code" target="_blank" rel="external">http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code</a>]</p>
<h1 id="作为一个构造函数使用"><a href="#作为一个构造函数使用" class="headerlink" title="作为一个构造函数使用"></a>作为一个构造函数使用</h1><hr>
<p>　　在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'Guoch'</span>);    <span class="comment">// Person &#123;name: "Guoch"&#125;</span></div></pre></td></tr></table></figure></p>
<p>　　我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象；当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = Person(<span class="string">'Guoch'</span>);<span class="comment">// Window</span></div></pre></td></tr></table></figure></p>
<p>　　其区别在于，如何调用函数（new）。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><hr>
<p>　　在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span>,</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Object &#123;name: "Guoch"&#125;</span></div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo2();</div></pre></td></tr></table></figure></p>
<p>　　可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数。</p>
<p>　　函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。根据例子我们理解一下这句话：在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj；</p>
<p>　　简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。</p>
<h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h1><hr>
<h5 id="在-js-中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的-this-指向："><a href="#在-js-中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的-this-指向：" class="headerlink" title="　　在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向："></a>　　在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向：</h5><h4 id="·call"><a href="#·call" class="headerlink" title="　　·call"></a>　　·call</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>
<p>　　它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<h4 id="·apply"><a href="#·apply" class="headerlink" title="　　·apply"></a>　　·apply</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun.apply(thisArg[, [arg1, arg2, ...]])</div></pre></td></tr></table></figure>
<p>　　它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）；</p>
<h4 id="·bind"><a href="#·bind" class="headerlink" title="　　·bind"></a>　　·bind</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = fun.bind(thisArg[, arg1[, arg2[, ...]]]);</div></pre></td></tr></table></figure>
<p>　　它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<p>　　这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例；<br>　　为一个普通函数指定 this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.call(obj);      <span class="comment">// Object &#123;name: "Guoch"&#125;</span></div></pre></td></tr></table></figure></p>
<p>　　可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功；</p>
<p>　　为对象中的方法指定一个 this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch'</span>,</div><div class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  name: <span class="string">'Guoch222222'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.foo.call(obj2);     <span class="comment">// Object &#123;name: "Guoch222222"&#125;</span></div></pre></td></tr></table></figure></p>
<p>　　可以看到，执行函数的时候这里的 this 指向了 obj2，成功；</p>
<p>　　为构造函数指定 this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch2222222'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person.call(obj, <span class="string">'Guoch'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Uncaught TypeError: Person.call is not a constructor(…)</span></div></pre></td></tr></table></figure></p>
<p>　　这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数；</p>
<p>　　换成 bind 试试：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch2222222'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Person2 = Person.bind(obj);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person2(<span class="string">'Guoch'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Person &#123;name: "Guoch"&#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj);</div><div class="line"></div><div class="line"><span class="comment">// Object &#123;name: "Guoch2222222"&#125;</span></div></pre></td></tr></table></figure></p>
<p>　　打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效；</p>
<p>　　因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效；</p>
<p>　　当然 bind 不仅可以指定 this ，还能传入参数，我们来试试这个操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'Guoch2222222'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Person2 = Person.bind(obj, <span class="string">'Guoch111111'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person2(<span class="string">'Guoch'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Person &#123;name: "Guoch111111"&#125;</span></div></pre></td></tr></table></figure></p>
<p>　　可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了；</p>
<h3 id="为箭头函数指定-this"><a href="#为箭头函数指定-this" class="headerlink" title="为箭头函数指定 this"></a>为箭头函数指定 this</h3><hr>
<p>　　我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> afoo = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">afoo(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// Window</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'qiutc'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">afoo.call(obj, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// Window</span></div></pre></td></tr></table></figure></p>
<p>　　可以看到，这里的 call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。</p>

        </div>

        <blockquote class="post-copyright">
    <!-- <div class="content">
        

        
    </div> -->
    <footer>
        <a href="http://www.vituyun.com">
            <img src="/img/avatar.jpg" alt="Guoch">
            Guoch
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.vituyun.com/2016/09/20/理解javascript中的this/&title=《理解javascript中的this》 — Guoch&pic=http://www.vituyun.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.vituyun.com/2016/09/20/理解javascript中的this/&title=《理解javascript中的this》 — Guoch&source=　　在学习javascript的过程中，有时候对于this的指向感觉迷迷糊糊的，所以我在查阅了相关资料之后针对javascript中的this做一个总结。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.vituyun.com/2016/09/20/理解javascript中的this/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《理解javascript中的this》 — Guoch&url=http://www.vituyun.com/2016/09/20/理解javascript中的this/&via=http://www.vituyun.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.vituyun.com/2016/09/20/理解javascript中的this/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2016/11/05/babel/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">babel学习</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2016/09/02/javascript闭包浅析/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">javascript闭包浅析</h4>
      </a>
    </div>
  
</nav>



    











</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢老板~~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        <!-- <span id="busuanzi_value_site_uv"></span> -->
        站点总访客数：156
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        <!-- <span id="busuanzi_value_site_pv"></span> -->
        站点总访问量：2896
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Guoch &copy; 2015 - 2017</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备1234556号-1</a><br>
                
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.vituyun.com/2016/09/20/理解javascript中的this/&title=《理解javascript中的this》 — Guoch&pic=http://www.vituyun.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.vituyun.com/2016/09/20/理解javascript中的this/&title=《理解javascript中的this》 — Guoch&source=　　在学习javascript的过程中，有时候对于this的指向感觉迷迷糊糊的，所以我在查阅了相关资料之后针对javascript中的this做一个总结。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.vituyun.com/2016/09/20/理解javascript中的this/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《理解javascript中的this》 — Guoch&url=http://www.vituyun.com/2016/09/20/理解javascript中的this/&via=http://www.vituyun.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.vituyun.com/2016/09/20/理解javascript中的this/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://www.vituyun.com/2016/09/20/理解javascript中的this/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '去哪啦！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
